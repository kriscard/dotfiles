#!/usr/bin/env bash

# Dotfiles CLI - Modern dotfiles management tool
# Inspired by dmmulroy's dot script
# Usage: dotfiles <command> [options]

set -e

# Get the directory where this script is located
# Get the directory where this script is located, resolving symlinks
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DOTFILES_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"

# Color definitions
readonly COLOR_GRAY="\033[1;38;5;243m"
readonly COLOR_BLUE="\033[1;34m"
readonly COLOR_GREEN="\033[1;32m"
readonly COLOR_RED="\033[1;31m"
readonly COLOR_PURPLE="\033[1;35m"
readonly COLOR_YELLOW="\033[1;33m"
readonly COLOR_NONE="\033[0m"

# Utility functions
title() {
    echo -e "\n${COLOR_PURPLE}$1${COLOR_NONE}"
    echo -e "${COLOR_GRAY}==============================${COLOR_NONE}\n"
}

error() {
    echo -e "${COLOR_RED}Error: ${COLOR_NONE}$1" >&2
    exit 1
}

warning() {
    echo -e "${COLOR_YELLOW}Warning: ${COLOR_NONE}$1"
}

info() {
    echo -e "${COLOR_BLUE}Info: ${COLOR_NONE}$1"
}

success() {
    echo -e "${COLOR_GREEN}âœ… $1${COLOR_NONE}"
}

prompt() {
    echo -e "${COLOR_BLUE}$1${COLOR_NONE}"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Confirmation prompt
confirm() {
    local message="$1"
    local default="${2:-n}"

    if [[ "$default" == "y" ]]; then
        prompt "$message [Y/n]: "
    else
        prompt "$message [y/N]: "
    fi

    read -r response
    response=${response:-$default}

    case "$response" in
        [yY][eE][sS]|[yY]) return 0 ;;
        *) return 1 ;;
    esac
}

# Version information
show_version() {
    echo "dotfiles v1.0.0"
    echo "Modern dotfiles management tool"
}

# Help system
show_help() {
    cat << EOF
dotfiles - Modern dotfiles management tool

Usage: dotfiles <command> [options]

Commands:
    init        Full system setup (packages, configs, symlinks)
    update      Update dotfiles and packages
    backup      Backup existing configurations
    restore     Restore from backup
    doctor      Run system diagnostics
    sync        Sync configuration files only (with conflict handling)
    stow        Create symlinks (quick stow)
    unstow      Remove symlinks (quick unstow)
    packages    Manage Homebrew packages only
    macos       Apply macOS settings only
    ds_store    Remove .DS_Store files from dotfiles

    help        Show this help message
    version     Show version information

Options:
    --dry-run   Show what would be done without making changes
    --force     Skip confirmation prompts
    --verbose   Show detailed output

Examples:
    dotfiles init           # Full system setup
    dotfiles backup         # Backup current configs
    dotfiles sync           # Sync configs only (handles conflicts)
    dotfiles stow           # Quick symlink creation
    dotfiles unstow         # Remove all symlinks
    dotfiles packages       # Install/update packages only
    dotfiles doctor         # Check system health
    dotfiles ds_store       # Remove .DS_Store files

For more information, visit: https://github.com/kriscard/.dotfiles
EOF
}

# Global options
DRY_RUN=false
FORCE=false
VERBOSE=false

# Parse global options
parse_options() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done
}

# Main command dispatcher
main() {
    # Parse global options first
    parse_options "$@"

    # Get the command (skip parsed options)
    local cmd=""
    for arg in "$@"; do
        case $arg in
            --dry-run|--force|--verbose)
                continue
                ;;
            *)
                cmd="$arg"
                break
                ;;
        esac
    done

    # Handle no command or help
    if [[ -z "$cmd" ]] || [[ "$cmd" == "help" ]] || [[ "$cmd" == "-h" ]] || [[ "$cmd" == "--help" ]]; then
        show_help
        exit 0
    fi

    # Handle version
    if [[ "$cmd" == "version" ]] || [[ "$cmd" == "-v" ]] || [[ "$cmd" == "--version" ]]; then
        show_version
        exit 0
    fi

    # Dispatch to command functions
    case "$cmd" in
        init)
            cmd_init
            ;;
        update)
            cmd_update
            ;;
        backup)
            cmd_backup
            ;;
        restore)
            cmd_restore
            ;;
        doctor)
            cmd_doctor
            ;;
        sync)
            cmd_sync
            ;;
        stow)
            cmd_stow
            ;;
        unstow)
            cmd_unstow
            ;;
        packages)
            cmd_packages
            ;;
        macos)
            cmd_macos
            ;;
        ds_store)
            cmd_ds_store
            ;;
        *)
            error "Unknown command: $cmd\n       Run 'dotfiles help' for available commands."
            ;;
    esac
}

# Command implementations (to be filled in next)

cmd_init() {
    title "ðŸš€ Initializing dotfiles setup"

    if [[ "$FORCE" != true ]]; then
        info "This will set up your entire development environment."
        info "It will install packages, create symlinks, and apply configurations."
        echo
        if ! confirm "Continue with full initialization?"; then
            info "Initialization cancelled."
            exit 0
        fi
    fi

    # Call individual setup functions
    cmd_backup
    cmd_packages
    cmd_sync
    cmd_macos

    success "Dotfiles initialization complete! ðŸŽ‰"
    info "You may need to restart your terminal or reload your shell."
}

cmd_update() {
    title "ðŸ”„ Updating dotfiles and packages"

    info "Pulling latest dotfiles..."
    if [[ "$DRY_RUN" == true ]]; then
        echo "[DRY RUN] Would run: git pull origin main"
    else
        git pull origin main || warning "Could not pull latest changes"
    fi

    info "Updating Homebrew packages..."
    cmd_packages

    success "Update complete!"
}

cmd_backup() {
    title "ðŸ’¾ Creating configuration backup"

    local backup_dir
    backup_dir="$HOME/dotfiles-backup-$(date +%Y%m%d-%H%M%S)"

    if [[ "$DRY_RUN" == true ]]; then
        echo "[DRY RUN] Would create backup directory: $backup_dir"
    else
        mkdir -p "$backup_dir"
        info "Created backup directory: $backup_dir"
    fi

    local config_dirs=(
        "$HOME/.config/nvim"
        "$HOME/.config/tmux"
        "$HOME/.config/kitty"
        "$HOME/.config/ghostty"
        "$HOME/.config/alacritty"
        "$HOME/.config/aerospace"
        "$HOME/.config/karabiner"
        "$HOME/.zshrc"
        "$HOME/.gitconfig"
    )

    for config in "${config_dirs[@]}"; do
        if [[ -e "$config" ]] && [[ ! -L "$config" ]]; then
            if [[ "$DRY_RUN" == true ]]; then
                echo "[DRY RUN] Would backup: $config"
            else
                cp -rf "$config" "$backup_dir/" 2>/dev/null || true
                success "Backed up: $(basename "$config")"
            fi
        fi
    done

    if [[ "$DRY_RUN" != true ]]; then
        success "Backup created at: $backup_dir"
    fi
}

cmd_restore() {
    title "ðŸ”„ Restoring from backup"
    error "Restore functionality not yet implemented"
    # TODO: Implement restore functionality
}

cmd_doctor() {
    title "ðŸ” Running system diagnostics"

    local issues=0

    # Check required tools
    info "Checking required tools..."

    local required_tools=("git" "curl" "zsh")
    for tool in "${required_tools[@]}"; do
        if command_exists "$tool"; then
            success "$tool is installed"
        else
            error "âŒ $tool is not installed"
            ((issues++))
        fi
    done

    # Check Homebrew
    if command_exists "brew"; then
        success "Homebrew is installed"

        if [[ "$VERBOSE" == true ]]; then
            info "Homebrew version: $(brew --version | head -n1)"
        fi

        # Check for outdated packages
        local outdated
        outdated=$(brew outdated --quiet)
        if [[ -n "$outdated" ]]; then
            warning "Some packages are outdated:"
            echo "$outdated" | sed 's/^/  /'
        else
            success "All packages are up to date"
        fi
    else
        warning "Homebrew is not installed"
        info "Run 'dotfiles packages' to install Homebrew"
    fi

    # Check shell
    if [[ "$SHELL" == */zsh ]]; then
        success "Using zsh shell"
    else
        warning "Not using zsh shell (current: $SHELL)"
        info "Run 'dotfiles macos' to set zsh as default shell"
    fi

    # Summary
    echo
    if [[ $issues -eq 0 ]]; then
        success "System health check passed! ðŸŽ‰"
    else
        warning "Found $issues issue(s) that need attention"
        info "Run 'dotfiles init' to fix these issues"
    fi
}

# Placeholder implementations for remaining commands
cmd_sync() {
    title "ðŸ”— Syncing configuration files"

    info "Creating symlinks with GNU Stow..."

    # Check if stow is installed
    if ! command_exists "stow"; then
        error "GNU Stow is not installed. Run 'dotfiles packages' first or install with: brew install stow"
    fi

    # Ensure we're in the dotfiles directory
    cd "$DOTFILES_DIR" || error "Cannot access dotfiles directory"

    if [[ "$DRY_RUN" == true ]]; then
        echo "[DRY RUN] Would create directory: $HOME/.config"
    else
        mkdir -p "$HOME/.config"
    fi

    # Handle conflicting files/directories
    local conflicting_paths=(
        "$HOME/.config/nvim"
        "$HOME/.config/tmux"
        "$HOME/.config/kitty"
        "$HOME/.config/ghostty"
        "$HOME/.config/alacritty"
        "$HOME/.config/aerospace"
        "$HOME/.config/karabiner"
        "$HOME/.zshrc"
        "$HOME/.claude"
    )

    for path in "${conflicting_paths[@]}"; do
        if [[ -e "$path" ]] && [[ ! -L "$path" ]]; then
            local backup_name
            backup_name="${path}.backup.$(date +%Y%m%d_%H%M%S)"
            if [[ "$DRY_RUN" == true ]]; then
                echo "[DRY RUN] Would backup: $path -> $backup_name"
            else
                warning "Backing up existing configuration: $(basename "$path")"
                mv "$path" "$backup_name"
            fi
        fi
    done

    # Stow packages
    local packages=(".config" "zsh" ".claude")

    for package in "${packages[@]}"; do
        if [[ -d "$package" ]]; then
            if [[ "$DRY_RUN" == true ]]; then
                echo "[DRY RUN] Would stow: $package"
            else
                info "Stowing $package..."
                if stow -t "$HOME" "$package" 2>/dev/null; then
                    success "Stowed $package"
                else
                    warning "Some symlinks for $package already exist. Restowing..."
                    stow -R -t "$HOME" "$package"
                    success "Restowed $package"
                fi
            fi
        fi
    done

    if [[ "$DRY_RUN" != true ]]; then
        success "Configuration files synced successfully!"
        info "Use 'dotfiles unstow' to remove symlinks if needed"
    fi
}

cmd_stow() {
    title "ðŸ”— Creating symlinks"

    # Check if stow is installed
    if ! command_exists "stow"; then
        error "GNU Stow is not installed. Run 'brew install stow' first."
    fi

    cd "$DOTFILES_DIR" || error "Cannot access dotfiles directory"

    if [[ "$FORCE" != true ]]; then
        info "This will create symlinks from dotfiles to your home directory."
        echo
        if ! confirm "Create symlinks?"; then
            info "Stow cancelled."
            return 0
        fi
    fi

    if [[ "$DRY_RUN" == true ]]; then
        info "Dry run - showing what would be symlinked:"
        stow -n -v .
    else
        if [[ "$VERBOSE" == true ]]; then
            stow -v .
        else
            stow .
        fi
        success "Symlinks created!"
    fi
}

cmd_unstow() {
    title "ðŸ”“ Removing symlinks"

    # Check if stow is installed
    if ! command_exists "stow"; then
        error "GNU Stow is not installed. Run 'brew install stow' first."
    fi

    cd "$DOTFILES_DIR" || error "Cannot access dotfiles directory"

    if [[ "$FORCE" != true ]]; then
        warning "This will remove all dotfiles symlinks from your home directory."
        echo
        if ! confirm "Remove all symlinks?"; then
            info "Unstow cancelled."
            return 0
        fi
    fi

    if [[ "$DRY_RUN" == true ]]; then
        info "Dry run - showing what would be removed:"
        stow -n -v -D .
    else
        if [[ "$VERBOSE" == true ]]; then
            stow -v -D .
        else
            stow -D .
        fi
        success "Symlinks removed!"
        info "Your home directory no longer links to dotfiles."
        info "Run 'dotfiles stow' to recreate symlinks."
    fi
}

cmd_packages() {
    title "ðŸ“¦ Managing Homebrew packages"

    # Install Homebrew if not present
    if ! command_exists "brew"; then
        info "Homebrew not installed. Installing..."
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would install Homebrew"
        else
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        fi
    else
        success "Homebrew is already installed"
    fi

    # Setup Homebrew environment for Linux
    if [[ "$(uname)" == "Linux" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would setup Homebrew environment for Linux"
        else
            test -d ~/.linuxbrew && eval "$(~/.linuxbrew/bin/brew shellenv)"
            test -d /home/linuxbrew/.linuxbrew && eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
            test -r ~/.bash_profile && echo "eval \$($(brew --prefix)/bin/brew shellenv)" >>~/.bash_profile
        fi
    fi

    # Install packages from Brewfile
    if [[ -f "$DOTFILES_DIR/Brewfile" ]]; then
        info "Installing packages from Brewfile..."
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would run: brew bundle --file=$DOTFILES_DIR/Brewfile"
        else
            brew bundle --file="$DOTFILES_DIR/Brewfile"
        fi
    else
        warning "Brewfile not found at $DOTFILES_DIR/Brewfile"
    fi

    # Install fzf key bindings
    if command_exists "brew" && [[ -f "$(brew --prefix)/opt/fzf/install" ]]; then
        info "Installing fzf key bindings..."
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would install fzf key bindings"
        else
            "$(brew --prefix)"/opt/fzf/install --key-bindings --completion --no-update-rc --no-bash --no-fish
        fi
    fi

    # Setup tmux TPM
    if [[ ! -d "$HOME/.tmux/plugins/tpm" ]]; then
        info "Installing TPM (Tmux Plugin Manager)..."
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would clone TPM repository"
        else
            git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
        fi
    fi

    # Install tmux plugins if tmux is running
    if pgrep -x "tmux" > /dev/null; then
        info "Installing tmux plugins..."
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would install tmux plugins"
        else
            ~/.tmux/plugins/tpm/bin/install_plugins
        fi
    else
        info "Tmux is not running. Start tmux and press prefix + I to install plugins"
    fi

    # Fetch Catppuccin themes
    info "Fetching Catppuccin themes..."
    local theme_dir="$DOTFILES_DIR/.config/kitty/themes"
    if [[ "$DRY_RUN" == true ]]; then
        echo "[DRY RUN] Would create theme directory: $theme_dir"
        echo "[DRY RUN] Would fetch Catppuccin themes"
    else
        mkdir -p "$theme_dir"
        for palette in frappe latte macchiato mocha; do
            curl -o "$theme_dir/catppuccin-$palette.conf" \
                "https://raw.githubusercontent.com/catppuccin/kitty/main/$palette.conf" 2>/dev/null || true
        done
    fi

    # Setup shell
    local zsh_path
    if command_exists "brew"; then
        zsh_path="$(brew --prefix)/bin/zsh"
    else
        zsh_path="$(which zsh)"
    fi

    if ! grep -q "$zsh_path" /etc/shells 2>/dev/null; then
        info "Adding $zsh_path to /etc/shells"
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would add $zsh_path to /etc/shells"
        else
            echo "$zsh_path" | sudo tee -a /etc/shells >/dev/null
        fi
    fi

    if [[ "$SHELL" != "$zsh_path" ]]; then
        info "Changing default shell to $zsh_path"
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would change shell to $zsh_path"
        else
            chsh -s "$zsh_path"
        fi
    fi

    # Setup terminfo
    info "Setting up terminfo..."
    if [[ "$DRY_RUN" == true ]]; then
        echo "[DRY RUN] Would install terminfo files"
    else
        tic -x "$DOTFILES_DIR/scripts/tmux.terminfo" 2>/dev/null || true
        tic -x "$DOTFILES_DIR/scripts/xterm-256color-italic.terminfo" 2>/dev/null || true

        # Install Ghostty terminfo if Ghostty is installed
        if command_exists "infocmp" && infocmp xterm-ghostty >/dev/null 2>&1; then
            info "Installing Ghostty terminfo for tmux support..."
            mkdir -p "$HOME/.terminfo"
            infocmp -x xterm-ghostty | tic -x -o "$HOME/.terminfo" - 2>/dev/null || true
            success "Ghostty terminfo installed"
        fi
    fi

    success "Package management complete!"
}

cmd_macos() {
    title "ðŸŽ Applying macOS settings"

    if [[ "$(uname)" != "Darwin" ]]; then
        warning "Not running on macOS. Skipping macOS-specific settings."
        return 0
    fi

    if [[ "$FORCE" != true ]]; then
        info "This will modify macOS system preferences."
        info "Some changes may require a restart to take effect."
        echo
        if ! confirm "Apply macOS settings?"; then
            info "macOS settings cancelled."
            return 0
        fi
    fi

    local settings=(
        "Finder: show all filename extensions"
        "defaults write NSGlobalDomain AppleShowAllExtensions -bool true"

        "Show hidden files by default"
        "defaults write com.apple.Finder AppleShowAllFiles -bool false"

        "Only use UTF-8 in Terminal.app"
        "defaults write com.apple.terminal StringEncodings -array 4"

        "Expand save dialog by default"
        "defaults write NSGlobalDomain NSNavPanelExpandedStateForSaveMode -bool true"

        "Show the ~/Library folder in Finder"
        "chflags nohidden ~/Library"

        "Enable full keyboard access for all controls"
        "defaults write NSGlobalDomain AppleKeyboardUIMode -int 3"

        "Enable subpixel font rendering on non-Apple LCDs"
        "defaults write NSGlobalDomain AppleFontSmoothing -int 2"

        "Use current directory as default search scope in Finder"
        "defaults write com.apple.finder FXDefaultSearchScope -string SCcf"

        "Show Path bar in Finder"
        "defaults write com.apple.finder ShowPathbar -bool true"

        "Show Status bar in Finder"
        "defaults write com.apple.finder ShowStatusBar -bool true"

        "Disable press-and-hold for keys in favor of key repeat"
        "defaults write NSGlobalDomain ApplePressAndHoldEnabled -bool false"

        "Set a blazingly fast keyboard repeat rate"
        "defaults write NSGlobalDomain KeyRepeat -int 1"

        "Set a shorter delay until key repeat"
        "defaults write NSGlobalDomain InitialKeyRepeat -int 15"

        "Enable tap to click (Trackpad)"
        "defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad Clicking -bool true"

        "Move Dock to right side"
        "defaults write com.apple.dock orientation -string right"

        "Set Dock icon size"
        "defaults write com.apple.dock tilesize -int 48"

        "Enable Dock autohide"
        "defaults write com.apple.dock autohide -bool true"

        "Remove Dock autohide delay"
        "defaults write com.apple.dock autohide-delay -float 0"

        "Speed up Dock autohide animation"
        "defaults write com.apple.dock autohide-time-modifier -float 0.5"

        "Don't rearrange Spaces based on recent use"
        "defaults write com.apple.dock mru-spaces -bool false"

        "Speed up Mission Control animations"
        "defaults write com.apple.dock expose-animation-duration -float 0.1"

        "Disable Spotlight keyboard shortcut (for Raycast)"
        "defaults write com.apple.symbolichotkeys AppleSymbolicHotKeys -dict-add 64 '{enabled = 0; value = { parameters = (65535, 49, 1048576); type = standard; };}'"

        "Save screenshots to Downloads folder"
        "defaults write com.apple.screencapture location -string \"${HOME}/Downloads\""

        "Save screenshots in PNG format"
        "defaults write com.apple.screencapture type -string png"

        "Disable screenshot shadow"
        "defaults write com.apple.screencapture disable-shadow -bool true"

        "Set trackpad tracking speed"
        "defaults write NSGlobalDomain com.apple.trackpad.scaling -float 3"

        "Enable three-finger drag"
        "defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool true"

        "Show battery percentage in menu bar"
        "defaults write com.apple.menuextra.battery ShowPercent -string YES"

        "Show date in menu bar"
        "defaults write com.apple.menuextra.clock DateFormat -string 'EEE d MMM HH:mm'"

        "Show POSIX path in Finder title"
        "defaults write com.apple.finder _FXShowPosixPathInTitle -bool true"

        "Disable .DS_Store on network drives"
        "defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool true"

        "Disable .DS_Store on USB drives"
        "defaults write com.apple.desktopservices DSDontWriteUSBStores -bool true"

        "Disable window animations"
        "defaults write NSGlobalDomain NSAutomaticWindowAnimationsEnabled -bool false"

        "Speed up dialog boxes"
        "defaults write NSGlobalDomain NSWindowResizeTime -float 0.001"
    )

    local i=0
    while [[ $i -lt ${#settings[@]} ]]; do
        local description="${settings[$i]}"
        local command="${settings[$((i+1))]}"

        info "$description"
        if [[ "$DRY_RUN" == true ]]; then
            echo "[DRY RUN] Would run: $command"
        else
            if [[ "$VERBOSE" == true ]]; then
                echo "  Running: $command"
            fi
            eval "$command" 2>/dev/null || warning "Failed to apply: $description"
        fi

        i=$((i+2))
    done

    if [[ "$DRY_RUN" != true ]]; then
        success "macOS settings applied successfully!"
        echo
        info "âš ï¸  Some changes require system restarts to take effect:"
        info "   â€¢ Restart Finder: killall Finder"
        info "   â€¢ Restart Dock: killall Dock"
        info "   â€¢ Some settings may need a full system restart"
        echo
        info "ðŸ’¡ Note: Spotlight shortcut disable may need manual verification in:"
        info "   System Settings â†’ Keyboard â†’ Keyboard Shortcuts â†’ Spotlight"
    fi
}

cmd_ds_store() {
    title "ðŸ§¹ Cleaning .DS_Store files"

    info "Searching for .DS_Store files in dotfiles repository and linked directories..."

    # Define search paths
    local search_paths=(
        "$DOTFILES_DIR"
        "$HOME/.config"
        # Add other relevant stowed directories if needed
    )

    # Find all .DS_Store files in the search paths
    # Ignore errors for paths that don't exist
    local ds_store_files
    ds_store_files=$(find "${search_paths[@]}" -name ".DS_Store" -type f 2>/dev/null)

    if [[ -z "$ds_store_files" ]]; then
        success "No .DS_Store files found! ðŸŽ‰"
        return 0
    fi

    # Read files into an array
    mapfile -t files_to_process <<< "$ds_store_files"

    # Count the files
    local file_count=${#files_to_process[@]}

    # Show found files
    info "ðŸ“ Found $file_count .DS_Store file(s):"
    echo
    for file in "${files_to_process[@]}"; do
        local display_path="$file"
        # Try to make path relative to HOME for cleaner display
        if [[ "$file" == "$HOME/"* ]]; then
            # shellcheck disable=SC2088  # Tilde intentional for display
            display_path="~/${file#$HOME/}"
        fi
        echo "  ðŸ“„ $display_path"
    done

    echo

    # Ask for confirmation unless force mode
    if [[ "$FORCE" != true ]] && [[ "$DRY_RUN" != true ]]; then
        echo
        if ! confirm "Remove $file_count .DS_Store file(s)?"; then
            info "Cleanup cancelled."
            return 0
        fi
    fi

    # Remove files
    if [[ "$DRY_RUN" == true ]]; then
        warning "[DRY RUN] Would remove $file_count .DS_Store file(s):"
        for file in "${files_to_process[@]}"; do
            local display_path="$file"
            if [[ "$file" == "$HOME/"* ]]; then
                # shellcheck disable=SC2088  # Tilde intentional for display
                display_path="~/${file#$HOME/}"
            fi
            echo "  ðŸ—‘ï¸  Would delete: $display_path"
        done
    else
        info "ðŸ—‘ï¸  Removing .DS_Store files..."
        echo

        local removed_count=0
        for file in "${files_to_process[@]}"; do
            local display_path="$file"
            if [[ "$file" == "$HOME/"* ]]; then
                # shellcheck disable=SC2088  # Tilde intentional for display
                display_path="~/${file#$HOME/}"
            fi

            if rm -f "$file"; then
                success "Deleted: $display_path"
                ((removed_count++))
            else
                warning "Failed to delete: $display_path"
            fi
        done

        echo
        if [[ $removed_count -eq $file_count ]]; then
            success "Cleanup complete! Removed $removed_count .DS_Store file(s) ðŸŽ‰"
        else
            warning "Removed $removed_count of $file_count .DS_Store file(s)"
        fi
    fi

    # Check and suggest .gitignore update (only for the main dotfiles repo)
    if [[ -f "$DOTFILES_DIR/.gitignore" ]]; then
        if ! grep -q "\.DS_Store" "$DOTFILES_DIR/.gitignore" 2>/dev/null; then
            echo
            info "ðŸ’¡ Tip: Add .DS_Store to your project's .gitignore to prevent future occurrences:"
            echo "       echo '.DS_Store' >> $DOTFILES_DIR/.gitignore"
        fi
    fi
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
